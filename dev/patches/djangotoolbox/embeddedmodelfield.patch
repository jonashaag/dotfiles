diff -r 0ec7bcacaeca djangotoolbox/fields.py
--- a/djangotoolbox/fields.py	Tue Oct 26 17:56:04 2010 +0200
+++ b/djangotoolbox/fields.py	Thu Nov 04 01:29:20 2010 +0100
@@ -3,7 +3,8 @@
 from django.db import models
 from django.core.exceptions import ValidationError
 
-__all__ = ('RawField', 'ListField', 'DictField', 'SetField', 'BlobField')
+__all__ = ('RawField', 'ListField', 'DictField', 'SetField',
+           'BlobField', 'EmbeddedModelField')
 
 class _HandleAssignment(object):
     """
@@ -167,3 +168,84 @@
 
     def value_to_string(self, obj):
         return str(self._get_val_from_obj(obj))
+
+
+class EmbeddedModelField(DictField):
+    """
+    Field that allows you to embed a model instance.
+
+    :param model: The model class that shall be embedded
+
+    For example, we want to namespace everything that belongs to a customer's
+    address into the ``address`` field::
+
+        class Address(models.Model):
+            street = models.CharField(max_length=200)
+            postal_code = models.IntegerField()
+            city = models.CharField(max_length=100)
+
+        class Customer(models.Model):
+            name = models.CharField(max_length=100)
+            last_name = models.CharField(max_length=100)
+            address = EmbeddedModelField(Address)
+
+    :class:`EmbeddedModelField` behaves similar to relations::
+
+        bob = Customer(
+           name='Bob', last_name='Laxley',
+           address=Address(street='Behind the Mountains 23',
+                           postal_code=1337, city='Blurginson')
+        )
+        assert bob.address.postal_code == 1337
+
+    When saved, embedded models are serialized to dictionaries. When queried,
+    the dictionary will be unserialized back to a model instance::
+
+        bob.save()
+        bob_from_db = Customer.objects.get(name='Bob')
+        assert bob_from_db.address.city == 'Blurginson'
+    """
+    __metaclass__ = models.SubfieldBase
+
+    def __init__(self, model, *args, **kwargs):
+        self.embedded_model = model
+        super(EmbeddedModelField, self).__init__(*args, **kwargs)
+
+    def get_db_prep_save(self, model_instance, connection):
+        if not model_instance:
+            return None
+
+        if not isinstance(model_instance, models.Model):
+            return model_instance
+
+        values = {}
+        for field in self.embedded_model._meta.fields:
+            values[field.name] = field.get_db_prep_save(
+                field.pre_save(model_instance, add=model_instance.pk is None),
+                connection=connection
+            )
+        return values
+
+    def get_db_prep_value(self, model_instance, connection, prepared=False):
+        if model_instance is None:
+            return None
+
+        if not isinstance(model_instance, models.Model):
+            return model_instance
+
+        values = {}
+        for field in self.embedded_model._meta.fields:
+            values[field.name] = field.get_db_prep_value(
+                getattr(model_instance, field.name),
+                connection=connection,
+                prepared=prepared
+            )
+        return values
+
+    def to_python(self, values):
+        if isinstance(values, dict):
+            if not values:
+                return None
+            return self.embedded_model(**values)
+        return values
+
